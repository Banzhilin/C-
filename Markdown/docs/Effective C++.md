# Effective C++

## 让自己习惯C++
* 条款01:视C++为一个语言联邦
  * C 
  > 此部分以C为基础，与C的基本语法基本别无二致，包括预编译、条件编译、struct、typedef、函数指针、变量、结构顺序等。
  
  * Object-Oriented C++
  > 此部分的C++主要是实现对于其对于面向对象的需求，其中包括classes（对象的构造、析构、函数操作符重载）、封装（private、protected、public）变量行为、继承、多态（vptr，表覆盖）、virtual、函数等

  * Template C++主要
  > 此部分是对于C++范型编程的描述，其具备独特的语法，其检查行为主要在于编译期，同时不同template<>块属于不同意义的部分，因为他们可以不同具象化（一定要注意），即在template class 里的与在temlate function的两处定义其分属两个块；在定义template时，如果需要对其进行偏特化，其在最初定义处需要对其实施默认版本，否则，在具体实现时编译器无法分清，会出现歧义

  * STL  
  > STL其是template的程序库，主要包括容器、迭代器、算法、以及函数对象的一个规约和协作
  
  * 注解：
  > 把C++看为几个不同的模块，其可以根据不同需求来选择所需要的部分进行组装，同时在不同的语言模块具备不同的特性，例如在对于函数传参时，内置类型进行pass-by-value传参，其比pass-by-reference更高效，后者有一层间接性；二在面向对象时，pass-by-reference具备更好的效率表现，主要是由于pass-by-value传参，其产生了间接对象，在构造和析构上耗费了性能；在STL中的迭代器和函数指针，本质都是指针，他们按值来传递具备较好的性能
  
  > 综上所述，C++的高效编程就不同模块来定，同时在学习的时候分模块来学习，会有较好的效果

* 条款02:尽量以const、enum、inline替换#define
  * #define
  > #define 是C部分的一个宏定义，它可以来定义宏变量例如:
  `#define MAX_INT 1000` 
  `int a = MAX_INT`
  > 其是在编译期对于所定义的宏进行替换，它在规范化、优化上具备很好的性质；同时它可以跟条件编译组合来进行根据不同的配置来编译不同的代码，如下：
  `#ifdef MAX_INT`
  `do something ...`
  `#endif`
  `在配置文件中`
  `#define MAX_INT`
  上述定义MAX_INT来进行对do something的选择编译；
  #define也可以进行简单宏函数定义：
  `#define MAX(A,B) (A > B ? A : B)`
  `int max = MAX(2,3)`
  相较于一般的函数调用，宏采取的是替换，其少了对于函数的调用（栈帧的转换），效率上较好（由于是替换，注意在编译期，代码量的膨胀）
  #define的不足：
  > * 其在编译期被替换，故在调试时无法追溯变量
  > * #define的作用域位于全局，当需要隐藏某些配置时，无法做到
  > * #define在做宏函数时无法对参数做类型检查
  > * #define在它的宏函数里如果包含其他运算，它会传导到每一处的替换中：
  `MAX(++a,b) --> (++a > b ? ++a : b)`
  
  > 使用const来替代对常量的定义
  `const int MAX_INT = 10;`
  `const int * const Point = &other`
  `class Demo{static const int MAX_INT = 10;} (若要在外部定义MAX_INT,请在实现文件中实现赋值，在声明文件中定义，会导致在多份文件中多次定义，引入头文件时) `
  `const int Demo::MAX_INT = 10;`
  上述实现了在定义常量上的对#define的替代，同时也可以限定访问域
  
  > 在类中需要定义一个数组可以通过enum(不可以取址)来设置长度：
   `class Demo {enum {LENGTH = 10}; int array[LENGTH];}`
   
  > 使用template + inline来替代宏函数，可以进行类型检测，同时可以规避宏函数中参杂表达式的错误：
  `template<class T>`
  `int max (T A , T B) {`
  ` return A > B ? A : B;`
  `}`
  
  > 注解：在遇见上述的三种情况时，请尽量使用此来替代#define，但是在需要域#ifdef、#ifndef等的组合时，#define无可替代
  
* 条款03:尽量使用const
  > const 在编译期检查，它表示所修饰的变量的不变性，被它修饰的变量拒绝变化（即被赋值），在类型转换时，可以让一个non-const变量转化为一个const变量，同时还可以防止变量被改变，故一般在传参时，可以令参数为const，它可以接受const、non-const变量；const变量不可以直接隐式转化为non-const，它需要const_cast<>来进行类型转化
  
  > const 的使用场景
  > * 修饰变量
  > `const int a = 0;`
  > 在定义const变量时，需要为其添加初始值，因为定义后不能对其进行修改，故必须初始化。
  > * 修饰指针
  > `int * const p = &a;`
  > `const int *p = &a; `
  > 前者表示指针的的指向的不变性，即不可以通过`p  = &other`；后者表示不可以通过指针来修改相应内存的值，即`*p = 2;`是非法的；
  > * 修饰class的成员变量
  > 使用const修饰的成员变量，必须在class构造函数的初始化列表进行赋值，其他地方赋值，除非const_cast，不能修改其不变性的意义
  > * 修饰成员函数（可以控制返回值作为左值还是右值）
  `class Demo {`
  `public:`
  `const int test () {}`
  `int test () const {}`
  `const int test1 () const {}`
  `}`
  > 第一个表示此成员函数返回一个不变的int，将返回值设置为const还有一个好处是在重载opertor+时`(a*b) = c`被编译器认为是错误的，因为`(a*b)`返回值是不可变的，它不可以作为左值；第二个表示常成员函数，在函数内部不可以修改函数的成员变量，其中编译器掺入的this指针为`const * const this`，除非成员变量使用mutable修饰；⚠️前两个具备不同意义，相当于重载；第三个是对于前两个结合；
  
  > 注：一般为了避免代码的重复性，我们可以在non-const函数中调用const版本的函数，由此也可以保持两个版本的一致性。
  
* 条款04:确定对象在使用前已被初始化
  > 在日常的开发过程中，时刻对于定义的变量进行正确的初始化是非常重要的，首先我们无法保证编译器的初始化行为，同是就程序运行时分配的栈/堆内存可能是刚被使用的，如果不进行显式的初始化，这会导致程序的不确定性
  
  > * 内置类型
  > 内置类型一般需要手动进行初始化
  > * class成员变量
  > 其中对于const修饰的成员变量必须在构造函数的初始化列表初始化；对于一般的类型，建议在初始化列表中初始化，一般的编译器会按照变量的初始化顺序（与初始化列表的顺序无关）来对成员进行初始化，主要行为是在构造函数执行语句前插入相应的初始化语句，其对于对象类型调用的是拷贝构造，相较于直接在构造函数内部里初始化，它少原来的先调用默认构造、在使用赋值操作符的代价
  ⚠️对于比较复杂的对象初始化，可以把其初始化步骤封装到一个private的成员函数中，返回一个变量，再使用相应的初始化列表或在构造函数里初始化（对于const的成员变量一般都采用这种方法）
  > * class 中static成员变量
  > 在比较新的编译器中，可以在class内的声明处进行初始化；在比价老的编译器中需要在实现文件中初始化，例如在Demo里定义了一个`static int a;`,其初始化为：
  `int Demo::a = 0;`
  > * 在两个不同的文件中需要一方的static来初始化
  > 其可以把static放置于一个函数中，同时这个函数返回此static的引用（类似于单例，将static变为指针即可，需要判空，同时需要考虑线程安全问题）

## 构造/析构/赋值运算
* 条款05:了解C++默认编写并调用那些函数
  > C++面向对象部分，相较于C来说，编译器动作更加明显，编译器的额外操作支撑了C++面向对象的大部分行为；例如构造函数的初始化、赋值操作符、隐式转换、虚拟函数、虚拟继承...在此条款简单介绍有关于C++编译器的一些默认函数操作
  
  > * default constructor 
  > 它是在函数没有定义其他构造函数时，编译器自动为类生成的构造函数，它可以进行一些默认的操作，比如调用基类的默认构造；但是当定义其他的构造函数后，编译器不会再为class自动生成默认构造函数；默认构造函数调用时机：
  `Demo demo;`
  `Demo *demo = new Demo();//先在heap开辟空间，再调用default constructor`
  
  > * desconstructor 析构函数
  > 它用来回收class的空间，在栈上的class的作用域结束时，默认调用；或者在堆上时，使用delete来显示回收并释放空间;可以重载析构函数来处理在class里的在堆上开辟的空间（否则易导致资源泄漏）
  
  > ⚠️在堆上的对象（new operator出来的对象）必须手动显式调用（或使用资源管理类）调用delete释放空间，否则会造成资源泄露。
  
  > copy constructor
  > 原型如下:
  `Demo (const Demo &)`
  其调用契机:
  `Demo demo(other);`
  `Demo demo = other;`
  `Demo *demo = new Demo(other);`
  `其他pass-to-value 函数临时值转换`
  上述都会引起默认copy constructor的调用，若为显式声明定义，编译器采用默认行为,一般为值拷贝，简单值赋值（指针指向同一快地方，非指针直接赋值），若要深拷贝需要重载，并开辟空间，再对空间值进行拷贝
  
  > copy assignment (operator=)
  > 原型如下:
  `Demo &operator= (const Demo &)`
  其调用契机:
  `Demo demo;`
  `demo = other;`
  上述都会引起默认copy assignment的调用，若为显式声明定义，编译器采用默认行为,一般为值拷贝，简单值赋值（指针指向同一快地方，非指针直接赋值），若要深拷贝需要重载，并开辟空间，再对空间值进行拷贝
  
  > ‼️一定需要自己定义copy constructor / copy assignment的情况：
  > * class包含reference的成员，由于其必须在构造的初始化列表中初始化，故需要自己提供copy constructor
  > * class 包含const成员变量，原理同上
  > * 在base class中copy constructor / copy assignment被声明为private时，需要自定义
  > * 当对象赋值需要深拷贝时，需要自定义copy constructor / copy assignment来进行相应操作

* 条款06:若不想使用编译器自动生成的函数，就应该明确拒绝
  > 在编译器的参与下，上述所谈及的默认生成的函数，会被编译器在任何需要的地方隐式的调用，对于copy constructor 和 copy assignment，当不需要时，可以声明其在class中的private下，表示以明确拒绝，这样在编译期，它会被检查出来
  
* 条款07:为多态基类声明virtual析构函数
* 条款08:别让异常逃离析构函数
* 条款09:绝不在构造函数和析构函数中调用virtual函数
* 条款10:令operator= 返回一个reference to *this
* 条款11:在operator= 中处理‘自我赋值’
* 条款12:赋值对象时勿忘其每一个成分

## 资源管理
* 条款13:以对象管理资源
* 条款14:在资源管理类中小心coping行为
* 条款15:在资源管理类中提供对原始资源的管理
* 条款16:成对使用new和delete时要采用相同的形式
* 条款17:以独立语句将newed对象置入智能指针中

## 设计与声明
* 条款18:让接口容易被正常使用，不易被误用
* 条款19:设计class犹如设计type
* 条款20:宁以pass-by-reference-to-const替换pass-by-value
* 条款21:必须返回对象时，别妄想返回局部对象的reference
* 条款22:将成员变量声明为private
* 条款23:宁以non-member、non-friend替换member函数
* 条款24:若成员函数的所有参数都需隐式转换，将其声明为non-member函数
* 条款25:考虑写一个不抛出异常的swap

## 实现
* 条款26:尽可能延后变量定义式出现的时间（需要时才定义）
* 条款27:尽量少做转型
* 条款28:避免返回handle指向内部成员
* 条款29:为异常安全的努力是值得的
* 条款30:透彻了解inline的里里外外
* 条款31:将文件间的依存关系降到最小

## 继承与面向对象设计
* 条款32:确定你的public是is-a关系
* 条款33:避免遮掩继承来的名称
* 条款34:区分接口继承和实现继承
* 条款35:考虑virtual函数以外的其他选择
* 条款36:绝不重新定义继承的non-virtual函数
* 条款37:绝不重新定义继承而来的缺省参数值
* 条款38:通过复合塑模出has-a或‘根据某物实现出’
* 条款39:明智而审慎地使用private继承
* 条款40:明智而审慎地使用多重继承

## 模版与范型编程
* 条款41:了解隐式接口和编译期多态
* 条款42:了解typename的双重含义
* 条款43:学习处理模版基类内的名称
* 条款44:将无关代码从template中抽离
* 条款45:利用成员函数模版接受所有兼容类型
* 条款46:需要类型转换时请为模版定义非成员函数
* 条款47:请使用traits classes表现类型信息
* 条款48:认识template元编程

## 定制new和delete
* 条款49:了解new-handler行为
* 条款50:了解new和delete的合理替换时机
* 条款51:编写new和delete要固守常规
* 条款52:写了placement new也要写placement delete

## 杂项
* 条款53:不要忽略编译器警告
* 条款54:让自己熟悉TR1在内的标准程序库
* 条款55:让自己熟悉Boost


